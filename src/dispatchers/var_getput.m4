dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2017, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdlib.h>

#include <pnetcdf.h>
#include <dispatch.h>
#include <pnc_debug.h>
#include <common.h>

include(`foreach.m4')dnl
include(`utils.m4')dnl

define(`GOTO_CHECK',`{ DEBUG_ASSIGN_ERROR(err, $1) goto err_check; }')

dnl CHECK_EINVALCOORDS(api_kind, start[i], count[i], shape[i])
define(`CHECK_EINVALCOORDS',dnl
`
#ifdef RELAX_COORD_BOUND
        if ($2 < 0 || $2 > $4)
            GOTO_CHECK(NC_EINVALCOORDS)
        if ($2 == $4) {
            ifelse(`$',`1',`/* for var1 APIs, count[0] is considered of 1 */
            GOTO_CHECK(NC_EINVALCOORDS)',`
            if (count != NULL && $3 > 0)
                GOTO_CHECK(NC_EINVALCOORDS)')
        }
#else
        if ($2 < 0 || $2 >= $4)
            GOTO_CHECK(NC_EINVALCOORDS)
#endif')dnl
dnl

dnl CHECK_EEDGE(start[i], count[i], stride[i], shape[i])
define(`CHECK_EEDGE',dnl
`
        ifelse(`$3',`',`/* vara APIs */
        if ($2 > $4 || $1 + $2 > $4)
            GOTO_CHECK(NC_EEDGE)',`
        if (stride == NULL) { /* vars APIs but stride is NULL */
            if ($2 > $4 || $1 + $2 > $4)
                GOTO_CHECK(NC_EEDGE)
        }
        else { /* for vars/varm APIs */
            if ($2 > 0 && $1 + ($2 - 1) * $3 >= $4)
                GOTO_CHECK(NC_EEDGE)
        }')')dnl
dnl

dnl CHECK_STRIDE
define(`CHECK_STRIDE',dnl
`
    /* Check NC_ESTRIDE for non-positive values. We did not check
     * stride[i] >= shape[i], as it is caught as NC_EEDGE error above */
    if (stride != NULL) {
        for (i=0; i<ndims; i++) {
            if (stride[i] <= 0)
                GOTO_CHECK(NC_ESTRIDE)
        }
    }')dnl
dnl

dnl SANITY_CHECK_ASM(get/put/iget/iput/bput, `'/1/a/s/m, `'/itype, `'/_all)
define(`SANITY_CHECK_ASM',dnl
`
    /* for API vara/vars/varm, count cannot be NULL, except for scalars */
    if (count == NULL) GOTO_CHECK(NC_EEDGE)

    firstDim = 0;
    /* check NC_EINVALCOORDS for record dimension */
    if (pncp->vars[varid].recdim >= 0) {
        if (count[0] < 0)  /* no negative count[] */
            GOTO_CHECK(NC_ENEGATIVECNT)

        /* for record variable, [0] is the NC_UNLIMITED dimension */
        /* read cannot go beyond current numrecs */
        ifelse(`$1',`put',`',`$1',`iput',`',`$1',`bput',`',
               `ifelse(`$2',`a',
               `CHECK_EEDGE(start[0], count[0], `',        shape[0])',
               `CHECK_EEDGE(start[0], count[0], stride[0], shape[0])')')

        firstDim = 1; /* skip checking the record dimension */
    }

    /* continue to check NC_EEDGE for the rest dimensions */
    for (i=firstDim; i<ndims; i++) {
        if (shape[i] < 0) GOTO_CHECK(NC_EEDGE)

        if (count[i] < 0) /* no negative count[] */
            GOTO_CHECK(NC_ENEGATIVECNT)

        ifelse(`$2',`a',
               `CHECK_EEDGE(start[i], count[i], `',        shape[i])',
               `CHECK_EEDGE(start[i], count[i], stride[i], shape[i])')
    }

    ifelse(`$2',`s',`CHECK_STRIDE', `$2',`m',`CHECK_STRIDE')
')dnl
dnl

dnl SANITY_CHECK_1ASM(get/put/iget/iput/bput, `'/1/a/s/m, `'/itype, `'/_all)
define(`SANITY_CHECK_1ASM',dnl
`
{   /* only var1, vara, vars, and varm APIs will reach here */
    int i, ndims, firstDim;
    MPI_Offset *shape=NULL;

    shape = pncp->vars[varid].shape;
    /* if record variable, inquire the current record size */
    if (pncp->vars[varid].recdim >= 0) {
        err = pncp->driver->inq_dim(pncp->ncp, pncp->vars[varid].recdim, NULL,
                                    &shape[0]);
        if (err != NC_NOERR) goto err_check;
    }

    /* Check NC_EINVALCOORDS error for argument start[]
     * for API var1/vara/vars/varm, start cannot be NULL, except for scalars
     * and negative start[] is illegal */
    if (start == NULL || start[0] < 0) GOTO_CHECK(NC_EINVALCOORDS)

    firstDim = 0;
    /* check NC_EINVALCOORDS for record dimension */
    if (pncp->vars[varid].recdim >= 0) {
        if (pncp->format < NC_FORMAT_CDF5 && start[0] > NC_MAX_UINT)
            GOTO_CHECK(NC_EINVALCOORDS) /* CDF-1 and 2 */

        /* for record variable, [0] is the NC_UNLIMITED dimension */
        /* read cannot go beyond current numrecs */
        ifelse(`$1',`put',`',`$1',`iput',`',`$1',`bput',`',
               `CHECK_EINVALCOORDS($3, start[0], count[0], shape[0])')
        firstDim = 1; /* done for checking the record dimension */
    }

    /* continue to check NC_EINVALCOORDS for the rest dimensions */
    ndims = pncp->vars[varid].ndims;
    for (i=firstDim; i<ndims; i++) {
        CHECK_EINVALCOORDS($3, start[i], count[i], shape[i])
    }

    /* Now check NC_EEDGE error for argument count[] */
    ifelse(`$2',`', `/* var  APIs have no count argument */',
           `$2',`1',`/* var1 APIs have no count argument */',
           `SANITY_CHECK_ASM($1, $2, $3, $4)')
}')dnl
dnl

dnl SANITY_CHECK(get/put/iget/iput/bput, `'/1/a/s/m, `'/itype, `'/_all)
define(`SANITY_CHECK',dnl
`
    ifelse(`$1',`get',`',`$1',`iget',`',`/* check file write permission */
    if (pncp->flag & NC_MODE_RDONLY) GOTO_CHECK(NC_EPERM)')

    /* blocking get/put must be called in data mode */
    ifelse(`$1',`put',`if (pncp->flag & NC_MODE_DEF) GOTO_CHECK(NC_EINDEFINE)',
           `$1',`get',`if (pncp->flag & NC_MODE_DEF) GOTO_CHECK(NC_EINDEFINE)')

    dnl for blocking APIs, check if in collective or independent mode */
    ifelse(`$1',`put',`ifelse(`$4',`_all',`
    /* check if in collective data mode */
    if (pncp->flag & NC_MODE_INDEP) GOTO_CHECK(NC_EINDEP)',`
    /* check if in independent data mode */
    if (!(pncp->flag & NC_MODE_INDEP)) GOTO_CHECK(NC_ENOTINDEP)')',
           `$1',`get',`ifelse(`$4',`_all',`
    /* check if in collective data mode */
    if (pncp->flag & NC_MODE_INDEP) GOTO_CHECK(NC_EINDEP)',`
    /* check if in independent data mode */
    if (!(pncp->flag & NC_MODE_INDEP)) GOTO_CHECK(NC_ENOTINDEP)')')

    /* variable NC_GLOBAL is illegal in this API */
    if (varid == NC_GLOBAL) GOTO_CHECK(NC_EGLOBAL)

    /* check whether variable ID is valid */
    if (varid < 0 || varid >= pncp->nvars) GOTO_CHECK(NC_ENOTVAR)

    /* check itype against xtype for NC_ECHAR */
    ifelse(`$3', `', `', `$3', `text',
    `if (pncp->vars[varid].xtype != NC_CHAR) GOTO_CHECK(NC_ECHAR)',
    `if (pncp->vars[varid].xtype == NC_CHAR) GOTO_CHECK(NC_ECHAR)')

    /* scalar variable */
    if (pncp->vars[varid].ndims == 0) goto err_check;

    ifelse(`$2',`', `/* done with var  as start/count/stride are NULL */',
           `$2',`d',`/* done with vard as start/count/stride are NULL */',
           `$2',`n',`/* done with varn: delay check */',
           `SANITY_CHECK_1ASM($1, $2, $3, $4)')

err_check:
    ifelse(`$4', `_all', `if (pncp->flag & NC_MODE_SAFE) {
        int minE, mpireturn;
        TRACE_COMM(MPI_Allreduce)(&err, &minE, 1, MPI_INT, MPI_MIN,
                                  pncp->comm);
        if (mpireturn != MPI_SUCCESS)
            return ncmpii_error_mpi2nc(mpireturn, "MPI_Bcast");
        if (minE != NC_NOERR) return minE;
    }
    else if (err == NC_EPERM || err == NC_EINDEFINE || err == NC_EINDEP ||
             err == NC_ENOTINDEP) {
        return err;  /* fatal error, cannot continue */
    }',`if (err != NC_NOERR) return err;')
')dnl
dnl

dnl
define(`APINAME',`ifelse(`$3',`',`ncmpi_$1_var$2$4',`ncmpi_$1_var$2_$3$4')')dnl
dnl
dnl GETPUT_API(get/put, `'/1/a/s/m, `'/itype, `'/_all)
dnl
define(`GETPUT_API',dnl
`dnl
/*----< APINAME($1,$2,$3,$4)() >---------------------------------------------*/
/* This API is ifelse(`$4',`',`an independent',`a collective') subroutine. */
int
APINAME($1,$2,$3,$4)(int ncid,
                     int varid,
                     ArgKind($2)
                     BufArgs($1,$3))
{
    int err1st=NC_NOERR, err, reqMode;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    SANITY_CHECK($1, $2, $3, $4)

    reqMode = NC_REQ_BLK |
              ifelse(`$1',`get',`NC_REQ_RD',`NC_REQ_WR') |
              ifelse(`$3',`',`NC_REQ_FLEX',`NC_REQ_HL') |
              ifelse(`$4',`',`NC_REQ_INDEP',`NC_REQ_COLL');

    ifelse(`$4',`_all',`/* if error, participate collective call */
    if (err != NC_NOERR) reqMode |= NC_REQ_ZERO;')

    err1st = err;

    /* call the subroutine that implements APINAME($1,$2,$3,$4)() */
    err = pncp->driver->`$1'_var(pncp->ncp,
                                  varid,
                                  ArgStartCountStrideMap($2),
                                  buf,
                                  ifelse(`$3',`',`bufcount, buftype',
                                                 `-1, ITYPE2MPI($3)'),
                                  API_KIND($2),
                                  reqMode);

    return (err1st != NC_NOERR) ? err1st : err;
}
')dnl
dnl

foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (put, get),
                 `foreach(`collindep', (, _all),
                          `foreach(`iType', (`',ITYPE_LIST),
                                   `GETPUT_API(putget,kind,iType,collindep)'
)')')')

/* ncmpi_get/put_varn_<type>_<mode> API:
 *    type:   data type of I/O buffer, buf
 *    mode:   independent (<nond>) or collective (_all)
 *
 * arguments:
 *    num:    number of start and count pairs
 *    starts: an 2D array of size [num][ndims]. Each starts[i][*] indicates
 *            the starting array indices for a subarray request. ndims is
 *            the number of dimensions of the defined netCDF variable.
 *    counts: an 2D array of size [num][ndims]. Each counts[i][*] indicates
 *            the number of array elements to be accessed. This argument
 *            can be NULL, equivalent to counts with all 1s.
 *    bufcount and buftype: these 2 arguments are only available for flexible
 *            APIs, indicating the I/O buffer memory layout. When buftype is
 *            MPI_DATATYPE_NULL, bufcount is ignored and the data type of buf
 *            is considered matched the variable data type defined in the file.
 */
dnl
define(`NAPINAME',`ifelse(`$2',`',`ncmpi_$1_varn$3',`ncmpi_$1_varn_$2$3')')dnl
dnl
dnl VARN(get/put, `'/iType, `'/_all)
dnl
define(`VARN',dnl
`dnl
/*----< NAPINAME($1,$2,$3)() >-----------------------------------------------*/
/* This API is ifelse(`$3',`',`an independent',`a collective') subroutine. */
int
NAPINAME($1,$2,$3)(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const *starts,
                   MPI_Offset* const *counts,
                   BufArgs($1,$2))
{
    int err, reqMode;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    reqMode = NC_REQ_BLK |
              ifelse(`$1',`get',`NC_REQ_RD',`NC_REQ_WR') |
              ifelse(`$2',`',`NC_REQ_FLEX',`NC_REQ_HL') |
              ifelse(`$3',`',`NC_REQ_INDEP',`NC_REQ_COLL');

    /* calling the subroutine that implements NAPINAME($1,$2,$3)() */
    return pncp->driver->`$1'_varn(pncp->ncp,
                                   varid,
                                   num,
                                   starts,
                                   counts,
                                   buf,
                                   ifelse(`$2',`',`bufcount, buftype',
                                                  `-1, ITYPE2MPI($2)'),
                                   reqMode);
}
')dnl
dnl

foreach(`putget', (put, get),
        `foreach(`iType', (`',ITYPE_LIST),
                 `foreach(`collindep', (, _all),
                          `VARN(putget,iType,collindep)'
)')')

dnl
define(`MAPINAME',`ifelse(`$3',`',`ncmpi_m$1_var$2$4',`ncmpi_m$1_var$2_$3$4')')dnl
dnl
define(`MArgStartCountStrideMap', `ifelse(
       `$1', `',  `NULL,      NULL,      NULL,       NULL',
       `$1', `1', `starts[i], NULL,      NULL,       NULL',
       `$1', `a', `starts[i], counts[i], NULL,       NULL',
       `$1', `s', `starts[i], counts[i], strides[i], NULL',
       `$1', `m', `starts[i], counts[i], strides[i], imaps[i]')')dnl
dnl
dnl MVAR(put/get, `'/1/a/s/m, `'/iType, `'/_all)
dnl
define(`MVAR',dnl
`dnl
/*----< MAPINAME($1,$2,$3,$4)() >--------------------------------------------*/
/* This API is ifelse(`$4',`',`an independent',`a collective') subroutine. */
int
MAPINAME($1,$2,$3,$4)(int                ncid,
                      int                nvars,
                      int               *varids,
                      ifelse(`$2', `1', `MPI_Offset* const *starts,',
                             `$2', `a', `MPI_Offset* const *starts,
                                         MPI_Offset* const *counts,',
                             `$2', `s', `MPI_Offset* const *starts,
                                         MPI_Offset* const *counts,
                                         MPI_Offset* const *strides,',
                             `$2', `m', `MPI_Offset* const *starts,
                                         MPI_Offset* const *counts,
                                         MPI_Offset* const *strides,
                                         MPI_Offset* const *imaps,')
                      ifelse(`$3', `',
                         `ifelse($1,`get',`void **bufs,',`void* const *bufs,')
                         const MPI_Offset *bufcounts,
                         const MPI_Datatype *buftypes',
                         `ifelse($1,`get',`FUNC2ITYPE($3) **bufs',
                                          `FUNC2ITYPE($3)* const *bufs')'))
{
    int i, reqMode, status=NC_NOERR, err, *reqs;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    reqMode = NC_REQ_NBI |
              ifelse(`$1',`get',`NC_REQ_RD',`NC_REQ_WR') |
              ifelse(`$3',`',`NC_REQ_FLEX',`NC_REQ_HL') |
              ifelse(`$4',`',`NC_REQ_INDEP',`NC_REQ_COLL');

    reqs = (int*) malloc((size_t)nvars * SIZEOF_INT);
    for (i=0; i<nvars; i++) {
        /* call the nonblocking subroutines */
        err = pncp->driver->i`$1'_var(pncp->ncp,
                                      varids[i],
                                      MArgStartCountStrideMap($2),
                                      bufs[i],
                                      ifelse(`$3',`',`bufcounts[i], buftypes[i]',
                                                     `-1, ITYPE2MPI($3)'),
                                      &reqs[i],
                                      API_KIND($2),
                                      reqMode);
        if (status == NC_NOERR) status = err;
    }

    err = pncp->driver->wait(pncp->ncp, nvars, reqs, NULL, reqMode);
    if (status == NC_NOERR) status = err;
    free(reqs);

    return status;
}
')dnl
dnl

foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (put, get),
                 `foreach(`collindep', (, _all),
                          `foreach(`iType', (`',ITYPE_LIST),
                                   `MVAR(putget,kind,iType,collindep)'
)')')')

dnl
define(`IAPINAME',`ifelse(`$3',`',`ncmpi_$1_var$2',`ncmpi_$1_var$2_$3')')dnl
dnl
dnl IGETPUT_API(iget/iput/bput, `'/1/a/s/m, `'/iType)
dnl
define(`IGETPUT_API',dnl
`dnl
/*----< IAPINAME($1,$2,$3)() >-----------------------------------------------*/
/* This API is an independent subroutine, which can be called in either
 * collective or independent data mode or even in define mode.
 */
int
IAPINAME($1,$2,$3)(int ncid,
                   int varid,
                   ArgKind($2)
                   BufArgs(substr($1,1),$3),
                   int *reqid)
{   
    int err, reqMode;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    reqMode = ifelse(`$1',`iget',`NC_REQ_RD | NC_REQ_NBI',
                     `$1',`iput',`NC_REQ_WR | NC_REQ_NBI',
                     `$1',`bput',`NC_REQ_WR | NC_REQ_NBB') |
              ifelse(`$3',`',`NC_REQ_FLEX',`NC_REQ_HL');

    /* calling the subroutine that implements IAPINAME($1,$2,$3)() */
    return pncp->driver->`$1'_var(pncp->ncp,
                                  varid,
                                  ArgStartCountStrideMap($2),
                                  buf,
                                  ifelse(`$3',`',`bufcount, buftype',
                                                 `-1, ITYPE2MPI($3)'),
                                  reqid,
                                  API_KIND($2),
                                  reqMode);
}
')dnl
dnl

foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (iput, iget, bput),
                 `foreach(`iType', (`',ITYPE_LIST),
                          `IGETPUT_API(putget,kind,iType)'
)')')


/* ncmpi_iget/iput_varn_<type>_<mode> API:
 *    type:   data type of I/O buffer, buf
 *    mode:   indpendent (<nond>) or collective (_all)
 *
 * arguments:
 *    num:    number of start and count pairs
 *    starts: an 2D array of size [num][ndims]. Each starts[i][*] indicates
 *            the starting array indices for a subarray request. ndims is
 *            the number of dimensions of the defined netCDF variable.
 *    counts: an 2D array of size [num][ndims]. Each counts[i][*] indicates
 *            the number of array elements to be accessed. This argument
 *            can be NULL, equivalent to counts with all 1s.
 *    bufcount and buftype: these 2 arguments are only available for flexible
 *            APIs, indicating the I/O buffer memory layout. When buftype is
 *            MPI_DATATYPE_NULL, bufcount is ignored and the data type of buf
 *            is considered matched the variable data type defined in the file.
 *    reqid:  request ID returned to user
 */
dnl
define(`INAPINAME',`ifelse(`$2',`',`ncmpi_$1_varn',`ncmpi_$1_varn_$2')')dnl
dnl
dnl IVARN(iget/iput/bput, `'/iType)
dnl
define(`IVARN',dnl
`dnl
/*----< INAPINAME($1,$2)() >--------------------------------------------------*/
/* This API is an independent subroutine, which can be called in either
 * collective or independent data mode or even in define mode.
 */
int
INAPINAME($1,$2)(int                ncid,
                 int                varid,
                 int                num,
                 MPI_Offset* const *starts,
                 MPI_Offset* const *counts,
                 BufArgs(substr($1,1),$2),
                 int               *reqid)
{
    int err, reqMode;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    reqMode = ifelse(`$1',`iget',`NC_REQ_RD | NC_REQ_NBI',
                     `$1',`iput',`NC_REQ_WR | NC_REQ_NBI',
                     `$1',`bput',`NC_REQ_WR | NC_REQ_NBB') |
              ifelse(`$2',`',`NC_REQ_FLEX',`NC_REQ_HL');

    /* calling the subroutine that implements INAPINAME($1,$2)() */
    return pncp->driver->`$1'_varn(pncp->ncp,
                                   varid,
                                   num,
                                   starts,
                                   counts,
                                   buf,
                                   ifelse(`$2',`',`bufcount, buftype',
                                                  `-1, ITYPE2MPI($2)'),
                                   reqid,
                                   reqMode);
}
')dnl
dnl

foreach(`putget', (iget, iput, bput),
        `foreach(`iType', (`',ITYPE_LIST),
                 `IVARN(putget,iType)'
)')

dnl
dnl VARD(get/put, `'/_all)
dnl
define(`VARD',dnl
`dnl
/*----< ncmpi_$1_vard$2() >--------------------------------------------------*/
/* This API is ifelse(`$4',`',`an independent',`a collective') subroutine. */
int
ncmpi_$1_vard$2(int           ncid,
                int           varid,
                MPI_Datatype  filetype,  /* access layout to the variable in file */
                ifelse($1, `get', `void *buf', `const void *buf'),
                MPI_Offset    bufcount,
                MPI_Datatype  buftype)   /* data type of the buffer */
{
    int err, reqMode;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    reqMode = NC_REQ_BLK | NC_REQ_FLEX |
              ifelse(`$1',`get',`NC_REQ_RD',`NC_REQ_WR') |
              ifelse(`$2',`',`NC_REQ_INDEP',`NC_REQ_COLL');

    /* calling the subroutine that implements ncmpi_$1_vard$2() */
    return pncp->driver->$1_vard(pncp->ncp,
                                 varid,
                                 filetype,
                                 buf,
                                 bufcount,
                                 buftype,
                                 reqMode);
}
')
dnl
foreach(`putget', (put, get),
        `foreach(`collindep', (, _all),
                 `VARD(putget,collindep)'
)')

